\documentclass{beamer}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{listings}

% --- Custom styling ---
\definecolor{AUred}{HTML}{9E1B32}
\setbeamercolor{alerted text}{fg=AUred}
\usetheme[progressbar=frametitle, sectionpage=progressbar]{metropolis}

\title{A Compositional Deadlock Detector for Android Java}
\date{\today}
\author{Darius Mure\c{s}an \and Henrique Luz \and Rui Xavier}
\institute{Aarhus University \\ Department of Computer Science}

\begin{document}

% --- Title ---
\maketitle

% =========================================================
\section{Overview}
% =========================================================

\begin{frame}{Overview}
  \begin{itemize}
    \item We present a \textbf{compositional static analysis} for detecting deadlocks in Android Java.
    \item Designed for \textbf{industrial-scale} codebases (tens of millions of lines).
    \item Implemented in \textbf{INFER}, deployed at Facebook for 2+ years.
    \item Achieves a \textbf{54\% developer fix rate}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Motivation}
% =========================================================

\begin{frame}{Why Study Deadlocks?}
  \begin{itemize}
    \item Deadlocks are a key challenge in concurrent programming.
    \item Occur when threads \alert{cyclically wait on each other’s locks}.
    \item Result: entire system halts — loss of responsiveness, reliability.
    \item Especially relevant for \textbf{Android apps} using Java’s \texttt{synchronized} blocks.
  \end{itemize}
\end{frame}

\begin{frame}{Classical Example}
  \begin{block}{Dijkstra’s Dining Philosophers}
    Five philosophers share forks and a bowl of spaghetti.  
    Each must hold two forks to eat — potential for a circular wait.
  \end{block}
  \begin{itemize}
    \item Illustrates the essential nature of deadlock: mutual waiting.
    \item Analogous to threads waiting for locks.
  \end{itemize}
\end{frame}

\begin{frame}{Deadlocks in Industry}
  \begin{itemize}
    \item At Facebook, Android apps exceed \textbf{10M+ lines of code}.
    \item Thousands of commits daily $\Rightarrow$ rapid iteration.
    \item Developers need feedback in \textbf{under 15 minutes}.
    \item Whole-program analyses are too slow and memory-intensive.
  \end{itemize}
  \vspace{0.7em}
  \begin{block}{Goal}
    \textbf{Fast, scalable, accurate deadlock detection} integrated into CI pipelines.
  \end{block}
\end{frame}

\begin{frame}{Challenges in Traditional Analyses}
  \begin{itemize}
    \item Reanalyze entire program on each commit.
    \item Poor scalability and high false-positive rates.
    \item Lack \textbf{compositionality}.
    \item Need: an analysis that focuses only on changed code and its dependencies.
  \end{itemize}
\end{frame}

% =========================================================
\section{Research Gap and Question}
% =========================================================

\begin{frame}{The Research Gap}
  \begin{itemize}
    \item Existing tools are \textbf{non-compositional}.
    \item They often trade soundness for scalability.
    \item We need a \textbf{mathematically grounded}, \textbf{incremental} analysis.
  \end{itemize}
  \vspace{0.5em}
  \begin{alertblock}{Core Challenge}
    Can we design a deadlock detector that is both
    \textbf{sound in theory} and \textbf{scalable in practice}?
  \end{alertblock}
\end{frame}

\begin{frame}{Research Question}
  \begin{block}{Main Question}
    Can we develop a \textbf{compositional deadlock detector}
    for \textbf{Android Java} that is sound, complete, and efficient
    for large industrial codebases?
  \end{block}
  \begin{itemize}
    \item Model Java concurrency with \textbf{balanced, re-entrant locks}.
    \item Detect deadlocks via \textbf{critical pairs}.
    \item Integrate into \textbf{INFER} for continuous integration.
  \end{itemize}
\end{frame}

% =========================================================
\section{Concurrent Programs}
% =========================================================

\begin{frame}{Abstract Language}
  \begin{itemize}
    \item Simplified model of Java concurrency:
    \[
      C ::= \texttt{skip} \mid \texttt{p()} \mid \texttt{acq}(\ell) \mid \texttt{rel}(\ell)
      \mid C;C \mid \texttt{if(*) then C else C} \mid \texttt{while(*) do C}
    \]
    \item Non-recursive procedures.
    \item \textbf{Balanced statements}: every \texttt{acq} has matching \texttt{rel}.
    \item Parallel program: \( C_1 \,||\, C_2 \,||\, ... \,||\, C_n \)
  \end{itemize}
\end{frame}

\begin{frame}{Balanced (Nested) Locks}
  \begin{itemize}
    \item Threads acquire and release locks in \textbf{LIFO} order.
    \item Corresponds to \texttt{synchronized} in Java.
    \item Ensures locks are \textbf{re-entrant and scoped}.
  \end{itemize}
  \begin{exampleblock}{Example}
  \texttt{acq(x); acq(y); rel(y); rel(x)}   Balanced  
  \texttt{acq(x); rel(y);}  Unbalanced
  \end{exampleblock}
\end{frame}

\begin{frame}{Semantics}
  \begin{itemize}
    \item Each thread has a \textbf{lock state}: mapping locks → acquisition counts.
    \item Deadlock occurs when every thread can take a local step,
          but no joint step is possible.
  \end{itemize}
  \[
  \langle C_1 || C_2, (L_1, L_2) \rangle
  \]
  \vspace{0.5em}
  \begin{block}{Key Idea}
    Deadlock arises when threads hold disjoint locks yet each waits on
    a lock held by another.
  \end{block}
\end{frame}

% =========================================================
\section{Program Execution Traces}
% =========================================================

\begin{frame}{Executions as Traces}
  \begin{itemize}
    \item Executions can be represented as strings of lock
          acquisitions/releases — e.g. `x y y x`.
    \item Balanced programs produce \textbf{Dyck words} (well-nested parentheses).
    \item Captures the essential locking behaviour.
  \end{itemize}
  \[
  L(C) = \{\text{all possible lock traces of } C\}
  \]
\end{frame}

\begin{frame}{Example Trace}
  \begin{exampleblock}{Example}
    \texttt{acq(x); if(*) then acq(y); rel(y); else acq(z); rel(z); rel(x)}  
    \[
    L(C) = \{\, x y y x,\, x z z x \,\}
    \]
  \end{exampleblock}
  \begin{itemize}
    \item Balanced structure guarantees decidability.
    \item Enables abstract reasoning about possible interleavings.
  \end{itemize}
\end{frame}

\begin{frame}{Traces as Finite Automata}
  \begin{itemize}
    \item Each balanced statement can be viewed as a \textbf{finite automaton}
          over lock actions.
    \item Allows algorithmic computation of lock dependencies.
    \item Provides the foundation for critical-pair analysis.
  \end{itemize}
\end{frame}

% =========================================================
\section{Soundness and Completeness}
% =========================================================

\begin{frame}{Deadlock Characterisation}
  \begin{block}{Critical Pair}
    \((X, \ell)\): some execution acquires lock \(\ell\)
    while holding all locks in \(X\).
  \end{block}
  \begin{itemize}
    \item Captures possible lock dependencies.
    \item Computed for each sequential thread.
  \end{itemize}
\end{frame}

\begin{frame}{Key Theorem (Simplified)}
  \begin{block}{Theorem 4.4 — Deadlock Condition}
    Program \( C_1 || ... || C_n \) deadlocks  
    iff there exist critical pairs \((X_i, \ell_i)\) s.t.
    \[
      \ell_i \in \bigcup_{j \neq i} X_j
      \quad \text{and} \quad
      X_i \cap \bigcup_{j \neq i} X_j = \emptyset
    \]
  \end{block}
  \vspace{0.5em}
  \textbf{Intuition:} Each thread holds a lock another needs.
\end{frame}

\begin{frame}{Illustrative Example}
  \begin{exampleblock}{Two-Thread Example}
  \texttt{C1: acq(x); acq(y); rel(y); rel(x)}  
  \texttt{C2: acq(y); acq(x); rel(x); rel(y)}
  \end{exampleblock}
  \[
  \begin{aligned}
  \text{Crit(C1)} &= \{(\emptyset, x), (\{x\}, y)\} \\
  \text{Crit(C2)} &= \{(\emptyset, y), (\{y\}, x)\}
  \end{aligned}
  \]
  Since \(x \in \{y\}\) and \(y \in \{x\}\), the condition holds — \alert{deadlock!}
\end{frame}

\begin{frame}{Proof Structure}
  \begin{itemize}
    \item Define executions $\rightarrow$ and parallel composition.
    \item Show equivalence between execution semantics and trace semantics.
    \item Prove critical-pair condition is \textbf{sound} (no missed deadlocks) and
          \textbf{complete} (no spurious ones).
  \end{itemize}
  \begin{block}{Result}
    Existence of deadlock <=> conflict between critical pairs.
  \end{block}
\end{frame}

% =========================================================
\section{Complexity}
% =========================================================

\begin{frame}{Computing Critical Pairs}
  \begin{itemize}
    \item Recursive equations (C1–C6) compute \texttt{Crit(C)} compositionally.
    \item Each construct (if, while, seq) has a local combination rule.
    \item \textbf{Example:}
      \[
        \text{Crit(acq($\ell$); C; rel($\ell$))} =
        \{(\emptyset, \ell)\} \cup \{(X\cup\{\ell\}, \ell') \mid (X,\ell')\in \text{Crit(C)}\}
      \]
  \end{itemize}
\end{frame}

\begin{frame}{Complexity Results}
  \begin{itemize}
    \item \textbf{Finite and computable}: $\text{Crit}(C)$ always finite.
    \item Deadlock detection problem is \textbf{decidable} and in NP.
    \item Non-recursive programs $\Rightarrow$ quadratic time.
    \item With procedures $\Rightarrow$ quasi-exponential.
  \end{itemize}
\end{frame}

% =========================================================
\section{Implementation}
% =========================================================

\begin{frame}{Implementation Overview}
  \begin{itemize}
    \item Implemented as an \textbf{abstract interpretation} within INFER.
    \item Computes method summaries: critical pairs + thread identity.
    \item Compositionally reuses summaries of unchanged methods.
  \end{itemize}
  \begin{block}{Core Idea}
    Analyse only modified methods and their dependents.
  \end{block}
\end{frame}

\begin{frame}{Abstract State Representation}
  \[
  \alpha = \langle L, Z \rangle
  \quad\text{where}\quad
  L = \text{lock state},\;
  Z = \text{set of critical pairs}
  \]
  \begin{itemize}
    \item Join operation: \( \langle L, Z_1 \rangle \sqcup \langle L, Z_2 \rangle = \langle L, Z_1 \cup Z_2 \rangle \)
    \item Each command updates this abstract state.
  \end{itemize}
\end{frame}

\begin{frame}{Compositionality}
  \begin{itemize}
    \item Procedure call depends only on:
    \begin{enumerate}
      \item Current abstract state.
      \item Precomputed summary of the callee.
    \end{enumerate}
    \item Enables incremental reanalysis — ideal for CI/CD.
  \end{itemize}
  \[
    \texttt{Jp()K⟨L,Z⟩ = ⟨L, Z U f(L, Crit(body(p)))⟩}
  \]
\end{frame}

\begin{frame}{Analysis for Android Java}
  \begin{itemize}
    \item \textbf{Balanced locking}: uses \texttt{synchronized}.
    \item \textbf{Partial path sensitivity}: e.g., for \texttt{tryLock()} and UI threads.
    \item \textbf{Lock naming:} access-path abstraction (\texttt{this.f.g}, etc.).
    \item \textbf{Thread inference:} uses annotations like \texttt{@UiThread}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Deployment and Results}
% =========================================================

\begin{frame}{Industrial Deployment}
  \begin{itemize}
    \item Deployed as part of Facebook’s \textbf{continuous integration system}.
    \item Runs automatically on every Android commit.
    \item Appears as an automated “reviewer” commenting on potential deadlocks.
  \end{itemize}
\end{frame}

\begin{frame}{Results and Impact}
  \begin{itemize}
    \item Deployed for \textbf{2+ years} on all Android commits.
    \item \textbf{500+} deadlock reports issued.
    \item \textbf{54\%} of reports fixed by developers.
    \item Median runtime (all analyses): \textbf{90 s per commit}.
    \item Analyses \textbf{2k–5k methods per commit}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Conclusion and Related Work}
% =========================================================

\begin{frame}{Related Work}
  \begin{itemize}
    \item Builds on automata-theoretic analyses of \textbf{pushdown systems}.
    \item Compared to prior tools:
      \begin{itemize}
        \item Compositional, not whole-program.
        \item Targets balanced re-entrant locks.
        \item Prioritizes \textbf{actionable results} over completeness.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
  \begin{itemize}
    \item Developed a \textbf{sound and complete} compositional analysis.
    \item Scales to tens of millions of lines.
    \item Successfully deployed in industry with tangible impact.
    \item Formalized and proven in \textbf{Coq (8.7k LOC)}.
  \end{itemize}
  \begin{block}{Future Work}
    Extend to recursive calls, deterministic control, and nested parallelism.
  \end{block}
\end{frame}

\begin{frame}[standout]
  \Huge Thank you! \\
  \vspace{1em}
  Questions?
\end{frame}

\end{document}
