\documentclass{beamer}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{stmaryrd}

% --- Custom styling ---
\definecolor{AUred}{HTML}{9E1B32}
\setbeamercolor{alerted text}{fg=AUred}
\setbeamercolor{itemize item}{fg=black}
\usetheme[progressbar=frametitle, sectionpage=progressbar]{metropolis}


\RequirePackage{etoolbox}
\RequirePackage{keyval}
\RequirePackage{calc}
\RequirePackage{pgfopts}
\RequirePackage{tikz}


\title{A Compositional Deadlock Detector for Android Java}
\date{\today}
\author{Darius Mure\c{s}an \and Henrique Luz \and Rui Xavier}
\institute{Aarhus University \\ Department of Computer Science}

\begin{document}

\newcommand{\nbnote}[3]{
  % \fbox{\bfseries\sffamily\scriptsize#1}
  \fcolorbox{gray}{yellow}{\bfseries\sffamily\scriptsize#1}
  {\color{#2} \sffamily\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}
  % {\color{#2} \sffamily\small$\textit{#3}$}
  % \marginpar{\fbox{\bfseries\sffamily#1}}
} 
\newcommand{\darius}[1]{\nbnote{Darius}{red}{#1}}
\newcommand{\rui}[1]{\nbnote{Rui}{blue}{#1}} %
\newcommand{\henrique}[1]{\nbnote{Henrique}{green}{#1}} %

% --- Title ---
\maketitle

%=========================================================
\section{Motivation}
%=========================================================

\begin{frame}{Deadlocks: A Refresher}
  \begin{itemize}
    \item A \textbf{deadlock} occurs when two or more threads are each
          waiting for the other to release a lock, so none can make progress.

    \begin{exampleblock}{Example (two threads, two locks)}
      \[
        \begin{array}{ll}
          \text{Thread 1:} & \texttt{acq(x); acq(y);} \\
          \text{Thread 2:} & \texttt{acq(y); acq(x);}
        \end{array}
      \]
    \end{exampleblock}
    \item One possible execution:
      \begin{enumerate}
        \item Thread 1 acquires \(x\)
        \item Thread 2 acquires \(y\)
        \item Thread 1 now waits for \(y\), Thread 2 waits for \(x\)
      \end{enumerate}

    \item Neither thread can continue $\Longrightarrow$ \alert{deadlock}.
  \end{itemize}
\end{frame}


\begin{frame}{Why Deadlocks Matter}
  \begin{itemize}
    \item Concurrency is everywhere in Android apps:
      \begin{itemize}
        \item UI thread + many background threads
        \item Callback-driven, event-based execution
        \item Shared mutable state (objects used as locks)
      \end{itemize}
    \item A \alert{deadlock} freezes part (or all) of the app:
      \begin{itemize}
        \item UI becomes unresponsive
        \item Background tasks never finish
        \item Users perceive the app as \emph{broken}
      \end{itemize}
    \item Avoiding and detecting deadlocks is a core reliability problem.
  \end{itemize}
\end{frame}

\begin{frame}{Industrial Setting: Facebook Android Apps}
  \begin{itemize}
    \item Target: large Android apps under continuous development:
      \begin{itemize}
        \item Tens of millions of lines of code (LoC)
        \item Thousands of revisions per day
      \end{itemize}
    \item Goal of the analysis:
      \begin{itemize}
        \item Run at code-review time on every commit
        \item Give feedback to developers \textbf{within minutes}
      \end{itemize}
    \item This rules out whole-program, from-scratch analyses for every change.
  \end{itemize}
\end{frame}

\begin{frame}{Key Challenges}
  \begin{itemize}
    \item \textbf{Scalability}:
      \begin{itemize}
        \item Cannot re-analyse the whole app for each commit
        \item Need a compositional, incremental analysis
      \end{itemize}
    \item \textbf{Usefulness for developers}:
      \begin{itemize}
        \item Too many false positives \(\Rightarrow\) warnings are ignored
        \item The focus is on \alert{actionable reports}, not proving absence of deadlocks
      \end{itemize}
    \item \textbf{The research question}: can we get both \textbf{theoretical guarantees}
      and \textbf{practical performance} at this scale?
  \end{itemize}
\end{frame}

% =========================================================
\section{Research Gap and Question}
% =========================================================

\begin{frame}{Limitations of Existing Approaches}
  \begin{itemize}
    \item Many existing deadlock analyses:
      \begin{itemize}
        \item Assume access to the \textbf{whole program}
        \item Do not support compositional, change-focused analysis
      \end{itemize}
    \item Tools often prioritise:
      \begin{itemize}
        \item Strong soundness guarantees
        \item But with high false-positive rates in practice
      \end{itemize}
    \item For huge codebases, this is misaligned with developer needs:
      \begin{itemize}
        \item Developers prefer fewer, more trustworthy warnings
        \item It is acceptable to miss some rare deadlocks
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Research Question}
  \begin{block}{Main Question}
    \vspace{0.1cm}
    Can we design a \textbf{compositional} static analysis for \textbf{Android Java}
    that detects deadlocks in large codebases, with:
    \begin{itemize}
      \item A clean \textbf{theoretical characterisation} of deadlocks
      \item A \textbf{decidable} and \textbf{tractable} core problem
      \item A practical implementation integrated in CI
    \end{itemize}
  \end{block}
  \end{frame}

\begin{frame}{High-Level Contributions}
  \begin{block}{High-Level Contributions}
    \begin{itemize}
      \item Abstract language with balanced re-entrant locks and nondeterministic control
      \item New deadlock condition based on \alert{critical pairs} of threads
      \item Proof that deadlock detection in this language is decidable and in NP
      \item Compositional implementation in Facebook's \texttt{INFER}, deployed at scale
    \end{itemize}
  \end{block}
\end{frame}

% =========================================================
\section{Concurrent Programs}
% =========================================================

\begin{frame}{Abstract Language for Concurrency}
  \begin{itemize}
    \item Abstracts away data and heap; focuses only on locks and control.
    \item Statements \(C\) are built from:
      \begin{align*}
      C ::= \texttt{skip} \mid \texttt{p()} \mid acq(\ell);C;rel(\ell) \mid \texttt{C;C} \\ \mid \texttt{if(*) then C else C} \mid \texttt{while(*) do C} \\
    \end{align*}
    \vspace{-1cm}
    \item \textbf{Balanced statements} enforce lock discipline:
      \begin{itemize}
        \item Locks must be released in LIFO order
        \item Models scoped constructs like \texttt{synchronized} and \texttt{std::lock\_guard}
      \end{itemize}
    \item A parallel program is an \(n\)-tuple \(C_1 \,||\, \dots \,||\, C_n\).
  \end{itemize}
\end{frame}

\begin{frame}{Example Program in the Abstract Language}
  \begin{exampleblock}{Example}
    \[
      C = acq(x);
          (\texttt{if(*) then } acq(y); rel(y)
          \texttt{ else skip});
        rel(x)
    \]
  \end{exampleblock}
  \vspace{-0.5cm}

  \begin{itemize}
    \item This program:
      \begin{itemize}
        \item Always acquires and releases \(x\)
        \item Nondeterministically either:
          \begin{itemize}
            \item acquires and releases \(y\), or
            \item does nothing in the branch
          \end{itemize}
      \end{itemize}
    \item Shows how nested acquisitions map to lock scopes in Java.
  \end{itemize}
\end{frame}


\begin{frame}{Lock States and Configurations}
  \begin{itemize}
    \item Locks are \textbf{re-entrant}:
      \begin{itemize}
        \item A thread can acquire the same lock multiple times
        \item Lock state \(L : \text{Locks} \to \mathbb{N}\) counts acquisitions
      \end{itemize}
    \item We write \(\lfloor L \rfloor = \{ \ell \mid L(\ell) > 0 \}\) for held locks.
    \item A configuration is a pair \(\langle C, L \rangle\):
      \begin{itemize}
        \item \(C\): current statement
        \item \(L\): lock state
      \end{itemize}
    \item A concurrent configuration:
      \[
        \langle C_1 || \dots || C_n, (L_1,\dots,L_n) \rangle
      \]
      where each thread has its own lock state.
  \end{itemize}
\end{frame}

\begin{frame}{Deadlock Definition (1)}
  \begin{itemize}
    \item Sequential step: \(\langle C, L \rangle \to \langle C', L' \rangle\).
      \begin{exampleblock}{Example} 
        \[
          \langle \texttt{acq(x);skip;rel(x)},\, L \rangle \;\to\; 
          \langle \texttt{skip;rel(x)},\, L[x{++}] \rangle
        \]
        (acquiring lock \(x\) increases its count)
      \end{exampleblock}

    \item Parallel step: advance one thread,
          provided it does not grab a lock already held by another thread.

    \item Intuitively, we are deadlocked when:
      \begin{itemize}
        \item Each thread can individually make a step (sequential)
        \item But no \emph{parallel} step is possible any more
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Deadlock Definition (2)}
  \begin{itemize}
    \item Formal definition (simplified):
      \begin{itemize}
        \item A concurrent configuration is deadlocked if at least two
              threads are stuck in this way.
        \item A program deadlocks if some reachable configuration is
              deadlocked.
      \end{itemize}
  \end{itemize}
\end{frame}


% =========================================================
\section{Critical Pairs and Deadlock Detection}
% =========================================================

\begin{frame}{Intuition: Critical Pairs}
  \begin{block}{Critical Pair (Informal)}
    \vspace{0.1cm}
    A \textbf{critical pair} of a thread is a pair \((X,\ell)\) such that
    some execution of the thread acquires an \emph{unheld} lock \(\ell\)
    while already holding exactly the set of locks \(X\).
  \end{block}
  \begin{itemize}
    \item Captures \alert{which locks are held} when a new lock is acquired.
    \item Abstracts away the concrete control-flow and interleavings.
    \item Each thread has a \textbf{finite} set of critical pairs.
  \end{itemize}
\end{frame}

\begin{frame}{Critical Pairs: A Simple Example}
  \begin{block}{Statement}
    \[
      C = acq(x);\ acq(y);\ rel(y);\ rel(x)
    \]
  \end{block}

  \begin{block}{Computing \(\text{Crit}(C)\)}
    \[
      \text{Crit}(C) = \{\, (\emptyset, x),\ (\{x\}, y) \,\}
    \]

    \begin{itemize}
      \item At the first acquisition of \(x\): no locks held  
            \(\Rightarrow (\emptyset, x)\)
      \item Later, the thread holds \(\{x\}\) when acquiring \(y\)  
            \(\Rightarrow (\{x\}, y)\)
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}{Two-Thread Deadlock Condition}
  \begin{block}{Deadlock Condition (2 Threads)}
    \vspace{0.1cm}
    For two statements \(C_1\) and \(C_2\) running concurrently:
    \[
      C_1 \,||\, C_2 \text{ deadlocks}
      \iff \exists (X_1,\ell_1) \in \text{Crit}(C_1),
                 (X_2,\ell_2) \in \text{Crit}(C_2)
    \]
    such that
    \[
      \ell_1 \in X_2,\quad \ell_2 \in X_1,\quad X_1 \cap X_2 = \emptyset.
    \]
  \end{block}
  \begin{itemize}
    \item Each thread holds a lock the other is trying to acquire.
    \item The currently held lock sets do not overlap.
    \item Generalises to arbitrarily many threads.
  \end{itemize}
\end{frame}

\begin{frame}{Example: Classic Two-Thread Deadlock}
  \begin{exampleblock}{Two Threads}
    \begin{align*}
      C_1 &: \; acq(x); acq(y); skip; rel(y); rel(x) \\
      C_2 &: \; acq(y); acq(x); skip; rel(x); rel(y)
    \end{align*}
  \end{exampleblock}
  \vspace{-0.5em}
  \begin{itemize}
    \item Critical pairs:
      \begin{align*}
        \text{Crit}(C_1) &= \{ (\emptyset, x), (\{x\}, y) \} \\
        \text{Crit}(C_2) &= \{ (\emptyset, y), (\{y\}, x) \}
      \end{align*}
    \item Take \((X_1,\ell_1) = (\{x\}, y)\) and \((X_2,\ell_2) = (\{y\}, x)\):
      \begin{itemize}
        \item \(\ell_1 = y \in X_2 = \{y\}\)
        \item \(\ell_2 = x \in X_1 = \{x\}\)
        \item \(X_1 \cap X_2 = \emptyset\)
      \end{itemize}
    \item Condition holds \(\Rightarrow\) \alert{deadlock is possible}.
  \end{itemize}
\end{frame}

\begin{frame}{Guard Locks: Breaking the Deadlock}
  \begin{exampleblock}{Adding a Guard Lock}
    \begin{align*}
      C'_1 &= acq(z); C_1; rel(z) \\
      C'_2 &= acq(z); C_2; rel(z)
    \end{align*}
  \end{exampleblock}
  \vspace{-0.5em}
  \begin{itemize}
    \item Now:
      \begin{align*}
        \text{Crit}(C'_1) &= \{ (\emptyset, z), (\{z\}, x), (\{z,x\}, y) \} \\
        \text{Crit}(C'_2) &= \{ (\emptyset, z), (\{z\}, y), (\{z,y\}, x) \}
      \end{align*}
    \item Any potentially conflicting critical pairs share lock \(z\):
      \[
        \{z,x\} \cap \{z,y\} = \{z\} \neq \emptyset
      \]
    \item Deadlock condition fails \(\Rightarrow\) \alert{no deadlock}.
    \item Intuition: \(z\) acts as a \emph{guard lock} protecting the region.
  \end{itemize}
\end{frame}

% =========================================================
\section{Program Execution Traces}
% =========================================================

\begin{frame}{Executions as Traces}
  \begin{itemize}
    \item Each step either:
      \begin{itemize}
        \item Leaves the lock state unchanged
        \item Acquires a lock \(\ell\)
        \item Releases a lock \(\ell\)
      \end{itemize}
    \item We record only lock actions as a \textbf{trace} over alphabet \(\Sigma\):
      \[
        \Sigma = \{ \ell \mid \ell \in \text{Locks} \} \cup \{ \overline{\ell} \mid \ell \in \text{Locks} \}
      \]
      \vspace{-1cm}
    \begin{exampleblock}{Example}
      \end{exampleblock}
  \begin{itemize}
    \item  Statement:
      \texttt{acq(x); if(*) then acq(y); rel(y) else acq(z); rel(z); rel(x)}
    \item Possible traces: \(x y \overline{y} \overline{x}\) and \(x z \overline{z} \overline{x}\)
  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Executions as Traces (Examples)}
  \begin{exampleblock}{Example Statement}
    \[
      C = acq(x); acq(y); rel(y); rel(x)
    \]
  \end{exampleblock}

  \begin{itemize}
    \item Valid trace:
      \[
        x\, y\, \overline{y}\, \overline{x}
      \]
    
      Let us now consider:
    \[
      C' = acq(x); acq(y); rel(x); rel(y)
    \]
    \item Invalid trace (bad nesting):
      \[
        x\, y\, \overline{x}\, \overline{y}
      \quad\Rightarrow\quad
      \text{lock } x \text{ released while } y \text{ still held}
      \]
  \end{itemize}
\end{frame}


\begin{frame}{Dyck Words and Balanced Locking}
  \begin{itemize}
    \item For balanced statements, traces are \textbf{Dyck words}:
      \begin{itemize}
        \item Well-parenthesised strings of opens and closes
        \item Locks always released in reverse order of acquisition
      \end{itemize}
    \item Key property:
      \begin{itemize}
        \item For any balanced statement \(C\), all traces in \(L(C)\) are Dyck words.
        \item Executions never underflow the lock stack.
      \end{itemize}
    \item This structure is crucial for the decidability and the critical-pair
          characterisation of deadlocks.
  \end{itemize}
\end{frame}

\begin{frame}{Dyck Words and Balanced Locking (Example)}
  \begin{itemize}
    \item For balanced statements, traces form \textbf{Dyck words}:
      \begin{itemize}
        \item Perfectly nested lock acquisitions / releases
        \item The lock stack never underflows
      \end{itemize}
  \end{itemize}

  \begin{exampleblock}{Valid Dyck Word}
    \[
      x\, y\, \overline{y}\, z\, \overline{z}\, \overline{x}
    \]
  \end{exampleblock}

  \begin{itemize}
    \item Corresponds to nested Acquireâ€“Release behaviour:
      \[
        acq(x);\; acq(y);\; rel(y);\; acq(z);\; rel(z);\; rel(x)
      \]
  \end{itemize}

  \begin{exampleblock}{Invalid Word}
    \[
      x\, y\, \overline{x}\, \overline{y}
    \]
  \end{exampleblock}

  \begin{itemize}
    \item Releases \(x\) before \(y\): violates LIFO discipline.
  \end{itemize}
\end{frame}


\begin{frame}{Languages of Statements}
  \begin{itemize}
    \item Each statement \(C\) defines a language \(L(C) \subseteq \Sigma^\star\):
      \begin{itemize}
        \item All traces of possible executions of \(C\)
      \end{itemize}
    \item Defined inductively:
    \vspace{-0.5cm}
    \begin{columns}[t]
      \begin{column}{0.48\textwidth}
        \[
          \begin{aligned}
            &\text{L}(\texttt{skip}) = \{\varepsilon\} \\
            &\text{L}(p()) = \text{L}(\text{body}(p)) \\
            &\text{L}(acq(\ell)) = \{\ell\} \\
            &\text{L}(\texttt{if(*) then } C_1 \texttt{ else } C_2) = \text{L}(C_1) \cup \text{L}(C_2) \\
          \end{aligned}
        \]
      \end{column}
      \begin{column}{0.48\textwidth}
        \[
          \begin{aligned}
            &\text{L}(rel(\ell)) = \{\overline{\ell}\} \\
            &\text{L}(C_1;C_2) = \text{L}(C_1) \cdot \text{L}(C_2) \\
            &\text{L}(\texttt{while(*) do } C) = \text{L}(C)^\ast
          \end{aligned}
        \]
      \end{column}
    \end{columns}
    \vspace{0.1cm}
    \item For balanced \(C\), \(L(C)\) is regular and consists of Dyck words.
  \end{itemize}
\end{frame}

% =========================================================
\section{Soundness and Completeness}
% =========================================================

\begin{frame}{Cumulative Lock Effect of a Trace}
  \begin{itemize}
    \item For a trace \(u \in \Sigma^\ast\),  
          \(\langle u \rangle\) denotes its \textbf{cumulative lock effect}:
      \begin{itemize}
        \item Start from the empty lock multiset
        \item Read actions in \(u\) left to right
        \item Each \(x\) increments the count of lock \(x\)
        \item Each \(\overline{x}\) decrements the count of lock \(x\)
      \end{itemize}

    \vspace{0.5em}

    \item The set of \emph{currently held locks} after reading \(u\) is:
      \[
        \lfloor \langle u \rangle \rfloor = \{\, \ell \mid \langle u \rangle(\ell) > 0 \,\}.
      \]
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{exampleblock}{Example}
    \vspace{0.1cm}
      Trace prefix: \(u = x\, y\, \overline{y}\)

      \[
      \begin{aligned}
        \langle \varepsilon \rangle &= \emptyset \\
        \langle x \rangle &= \{x\} \\
        \langle x y \rangle &= \{x, y\} \\
        \langle x y \overline{y} \rangle &= \{x\}
      \end{aligned}
      \]

      So:
      \[
        \lfloor \langle u \rangle \rfloor = \{x\}.
      \]
    \end{exampleblock}
\end{frame}

\begin{frame}{Critical Pairs: Formal Definition}
  \begin{block}{Critical Pairs of a Statement}
    \vspace{0.1cm}
    For a balanced statement \(C\):
    \[
      \text{Crit}(C) = \{ (\lfloor \langle u \rangle \rfloor, \ell)
      \mid \exists v.\; u \ell v \in L(C) \ \text{and}\ \ell \notin \lfloor \langle u \rangle \rfloor \}
    \]
    where \(\langle u \rangle\) is the cumulative lock effect of trace \(u\).
  \end{block}
  \begin{itemize}
    \item This is equivalent to: \emph{there exists an execution that acquires \(\ell\)
          while holding exactly \(X\)}.
    \item The paper shows the execution-based and language-based definitions coincide.
  \end{itemize}
\end{frame}

\begin{frame}{Critical Pairs: Formal Definition (Example)}
  \begin{exampleblock}{Example Trace}
    \[
      u\ell v = x\, y\, z\, \overline{z}\, \overline{y}\, \overline{x}
    \]
  \end{exampleblock}

  \begin{itemize}
    \item Take \(u = x\, y\), \(\ell = z\):
      \[
        \langle u \rangle = \{x, y\}
      \]
    \item Since \(z \notin \{x, y\}\), acquiring \(z\) yields:
      \[
        (\{x, y\}, z) \in \text{Crit}(C)
      \]
    \item Meaning:  
      During some execution, the thread acquires \(z\) while holding exactly \(\{x, y\}\).
  \end{itemize}
\end{frame}


\begin{frame}{Deadlock Characterisation Theorem}
  \begin{block}{Theorem 4.4 (Simplified)}
    \vspace{0.1cm}
    A parallel program \(C_1 || \dots || C_n\) deadlocks
    iff there exists an index set \(I \subseteq \{1,\dots,n\}\) with \(|I| \ge 2\)
    and critical pairs \((X_i,\ell_i) \in \text{Crit}(C_i)\) for each \(i \in I\) such that:
    \[
      X_i \cap \bigcup_{j \neq i} X_j = \emptyset
      \quad\text{and}\quad
      \ell_i \in \bigcup_{j \neq i} X_j \quad \text{for all } i \in I.
    \]
  \end{block}
  \begin{itemize}
    \item Each thread holds locks needed by the others.
    \item Held-lock sets are pairwise disjoint.
    \item This condition is both \textbf{sound} and \textbf{complete}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Complexity}
% =========================================================

\begin{frame}{Computing Critical Pairs Compositionally}
  \begin{itemize}
    \item The paper gives 6 equations describing \(\text{Crit}(C)\)
          \emph{by syntax} of \(C\).
    \item Examples:
      \begin{align*}
&\text{Crit}(\texttt{skip}) = \emptyset \\
&\text{Crit}(p()) = \text{Crit}(\text{body}(p)) \\[0.4em]
&\text{Crit}(C;C') = \text{Crit}(C) \cup \text{Crit}(C') \\
&\text{Crit}(\texttt{if(*) then } C \texttt{ else } C') = 
\text{Crit}(C) \cup \text{Crit}(C') \\[0.4em]
&\text{Crit}(acq(\ell);C;rel(\ell)) = \\
&\{(\emptyset,\ell)\} \cup \{(X \cup \{\ell\},\ell') \mid (X,\ell') \in \text{Crit}(C),\ \ell' \neq \ell \}
\end{align*}

    \item These identities allow a bottom-up computation of \(\text{Crit}(C)\).
  \end{itemize}
\end{frame}

\begin{frame}{Complexity Bounds}
  \begin{itemize}
    \item \textbf{Finite} and \textbf{computable}:
      \begin{itemize}
        \item For any balanced \(C\), \(\text{Crit}(C)\) is finite.
      \end{itemize}
    \item Complexity of deadlock detection:
      \begin{itemize}
        \item The deadlock problem for this language is \textbf{decidable} and lies in \textbf{NP}.
        \item Idea: nondeterministically guess a set of threads and critical pairs,
              then check the deadlock condition in polynomial time.
      \end{itemize}
    \item For programs without procedure calls:
      \begin{itemize}
        \item Computing \(\text{Crit}(C)\) is polynomial in program size.
      \end{itemize}
    \item Lower bounds (e.g.\ NP-completeness) are left as future work.
  \end{itemize}
\end{frame}

% =========================================================
\section{Implementation}
% =========================================================

\begin{frame}{Core Abstract Interpretation}
  \begin{itemize}
    \item Implementation is an abstract interpretation that computes critical pairs.
    \item Abstract state:
      \[
        \alpha = \langle L, Z \rangle
      \]
      where
      \begin{itemize}
        \item \(L\): abstract lock state
        \item \(Z\): set of (approximate) critical pairs
      \end{itemize}
    \item Each command \(C\) defines a transformer $\llbracket C \rrbracket(\alpha)$.
    \item The join operation on states:
      \[
        \langle L, Z_1 \rangle \sqcup \langle L, Z_2 \rangle
        = \langle L, Z_1 \cup Z_2 \rangle
      \]
  \end{itemize}
\end{frame}

\begin{frame}{Compositionality of the Analysis}
  \begin{itemize}
    \item Procedure calls are handled via \textbf{summaries}:
      \begin{itemize}
        \item For each procedure \(p\) we precompute \(\text{Crit}(\text{body}(p))\).
        \item At a call \(p()\), we combine the current state with \(p\)'s summary.
      \end{itemize}
    \item Consequences:
      \begin{itemize}
        \item When code changes, only affected procedures and their callers need re-analysis.
        \item Most of the program can be reused from previous runs.
        \item This is essential for deployment in continuous integration.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Adapting to Android Java}
  \begin{itemize}
    \item The abstract language is mapped to real Java/Android code:
      \begin{itemize}
        \item \texttt{synchronized} methods/blocks \(\Rightarrow\) balanced lock regions
        \item Re-entrant monitors modelled as nested acquisitions
      \end{itemize}
    \item Android-specific refinements:
      \begin{itemize}
        \item Partial path-sensitivity for methods like \texttt{tryLock()} and UI-thread checks
        \item Lock naming via access-paths (\texttt{this.f.g}, etc.)
        \item Thread identity domain (\texttt{@UiThread}, \texttt{@WorkerThread}, background)
      \end{itemize}
    \item Implemented as the \texttt{starvation} analyser inside \texttt{INFER}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Deployment and Results}
% =========================================================

\begin{frame}{Integration in Facebook's CI}
  \begin{itemize}
    \item \texttt{INFER} is part of Facebook's continuous integration:
      \begin{itemize}
        \item Every Android commit triggers static analyses, including deadlock analysis.
        \item The analyser appears as an automated reviewer on code reviews.
      \end{itemize}
    \item The deadlock analysis targets \textbf{code changes}, not whole apps:
    \vspace{-0.4cm}
      \begin{itemize}
        \item Summarise modified methods and their dependents
        \item Use heuristics to find relevant methods that share locks
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Quantitative Impact}
  \begin{itemize}
    \item Deployed on all Android commits for \(\sim\)2 years.
    \item Scale:
      \begin{itemize}
        \item Hundreds of thousands of commits analysed
        \item Typically \(2\text{k} - 5\text{k}\) methods per commit
      \end{itemize}
    \item Performance:
      \begin{itemize}
        \item Median analysis time of 90 seconds per commit
        \item Average analysis time of 213 seconds per commit
      \end{itemize}
    \item Effectiveness:
      \begin{itemize}
        \item 500+ deadlock reports issued
        \item \(\sim 54\%\) of these reports were fixed by developers
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Practical Considerations}
  \begin{itemize}
    \item The tool optimises for \textbf{actionability}, not pure soundness:
      \begin{itemize}
        \item Prefers fewer, high-quality warnings
        \item Accepts some false negatives to keep the noise low
      \end{itemize}
    \item Some non-fixed reports:
      \begin{itemize}
        \item May still be real bugs (fixed elsewhere or considered low priority)
        \item Some are false positives (e.g.\ infeasible concurrency patterns)
      \end{itemize}
    \item Overall: evidence that the analysis finds real, impactful bugs at scale.
  \end{itemize}
\end{frame}

% =========================================================
\section{Conclusion and Related Work}
% =========================================================

\begin{frame}{Related Work}
  \begin{itemize}
    \item \textbf{Automata-theoretic} approaches
    \item \textbf{Static analyses} for deadlocks
    \item \textbf{Dynamic and hybrid} techniques
    \item This paper:
      \begin{itemize}
        \item Places a compositional static analysis with strong theory into this landscape
        \item Focuses on large-scale industrial deployment
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Takeaways}
  \begin{itemize}
    \item A new, \textbf{critical-pair based} characterisation of deadlocks for a balanced lock language.
    \item Deadlock detection in this setting is \textbf{decidable} and in \textbf{NP}.
    \item A compositional implementation scaled to tens of millions of LoC in production.
    \item \textbf{Formalisation}: full development mechanised in Coq (\(\sim 8.7\text{k}\) LOC).
  \end{itemize}

\end{frame}

\begin{frame}{Future Work}
  \begin{block}{Future Directions}
    \begin{itemize}
      \item Extend the theory to richer languages (recursion, deterministic guards, nested parallelism)
      \item Sharpen complexity bounds (e.g.\ NP-completeness)
      \item Explore similar compositional ideas for other concurrency bugs
    \end{itemize}
  \end{block}
\end{frame}

\section{Pros and Cons}

\begin{frame}{Pros}
\begin{itemize}
    \item Achieves a balance between solid theory and real industrial deployment.
    \item Compositionality is not only formal but practical in CI workflows.
    \item Critical pairs provide compact, human-interpretable summaries of thread behaviour.
    \item Abstraction is stable across code evolution, making the analysis maintainable long-term.
\end{itemize}
\end{frame}

\begin{frame}{Cons}
\begin{itemize}
    \item Compositionality may miss multi-layer deadlocks spread across the call graph (false negatives).
    \item Strong reliance on balanced locking assumptions; custom sync patterns break the model.
    \item The first full-program analysis remains expensive despite good per-commit performance.
    \item The reported statistics aggregate all categories of deadlock reports; separating them would clarify how many were real bugs, low-priority issues, or false positives.
    \item The evaluation reports total CI analysis time, but does not isolate the cost of \emph{this} analyser, making its standalone overhead harder to assess.
\end{itemize}
\end{frame}

\begin{frame}[standout]
  \Huge Thank you! \\
  \vspace{1em}
  Questions?
\end{frame}

\end{document}
