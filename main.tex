\documentclass{beamer}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{stmaryrd}

% --- Custom styling ---
\definecolor{AUred}{HTML}{9E1B32}
\setbeamercolor{alerted text}{fg=AUred}
\usetheme[progressbar=frametitle, sectionpage=progressbar]{metropolis}


\RequirePackage{etoolbox}
\RequirePackage{keyval}
\RequirePackage{calc}
\RequirePackage{pgfopts}
\RequirePackage{tikz}


\title{A Compositional Deadlock Detector for Android Java}
\date{\today}
\author{Darius Mure\c{s}an \and Henrique Luz \and Rui Xavier}
\institute{Aarhus University \\ Department of Computer Science}

\begin{document}

\newcommand{\nbnote}[3]{
  % \fbox{\bfseries\sffamily\scriptsize#1}
  \fcolorbox{gray}{yellow}{\bfseries\sffamily\scriptsize#1}
  {\color{#2} \sffamily\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}
  % {\color{#2} \sffamily\small$\textit{#3}$}
  % \marginpar{\fbox{\bfseries\sffamily#1}}
} 
\newcommand{\darius}[1]{\nbnote{Darius}{red}{#1}}
\newcommand{\rui}[1]{\nbnote{Rui}{blue}{#1}} %
\newcommand{\henrique}[1]{\nbnote{Henrique}{green}{#1}} %

% --- Title ---
\maketitle

%=========================================================
\section{Motivation}
%=========================================================

\begin{frame}{Why Deadlocks Matter}
  \begin{itemize}
    \item Concurrency is everywhere in Android apps:
      \begin{itemize}
        \item UI thread + many background threads
        \item Callback-driven, event-based execution
        \item Shared mutable state (objects used as locks)
      \end{itemize}
    \item A \alert{deadlock} freezes part (or all) of the app:
      \begin{itemize}
        \item UI becomes unresponsive
        \item Background tasks never finish
        \item Users perceive the app as \emph{broken}
      \end{itemize}
    \item Avoiding and detecting deadlocks is a core reliability problem.
  \end{itemize}
\end{frame}

\begin{frame}{Industrial Setting: Facebook Android Apps}
  \begin{itemize}
    \item Target: large Android apps under continuous development:
      \begin{itemize}
        \item Tens of millions of lines of code (LoC)
        \item Thousands of revisions per day
      \end{itemize}
    \item Goal of the analysis:
      \begin{itemize}
        \item Run at code-review time on every commit
        \item Give feedback to developers \textbf{within minutes}
      \end{itemize}
    \item This rules out whole-program, from-scratch analyses for every change.
  \end{itemize}
\end{frame}

\begin{frame}{Key Challenges}
  \begin{itemize}
    \item \textbf{Scalability}:
      \begin{itemize}
        \item Cannot re-analyse the whole app for each commit
        \item Need a compositional, incremental analysis
      \end{itemize}
    \item \textbf{Usefulness for developers}:
      \begin{itemize}
        \item Too many false positives \(\Rightarrow\) warnings are ignored
        \item The focus is on \alert{actionable reports}, not proving absence of deadlocks
      \end{itemize}
    \item \textbf{The research question}: can we get both \textbf{theoretical guarantees}
      and \textbf{practical performance} at this scale?
  \end{itemize}
\end{frame}

% =========================================================
\section{Research Gap and Question}
% =========================================================

\begin{frame}{Limitations of Existing Approaches}
  \begin{itemize}
    \item Many existing deadlock analyses:
      \begin{itemize}
        \item Assume access to the \textbf{whole program}
        \item Do not support compositional, change-focused analysis
      \end{itemize}
    \item Tools often prioritise:
      \begin{itemize}
        \item Strong soundness guarantees
        \item But with high false-positive rates in practice
      \end{itemize}
    \item For huge codebases, this is misaligned with developer needs:
      \begin{itemize}
        \item Developers prefer fewer, more trustworthy warnings
        \item It is acceptable to miss some rare deadlocks
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Research Question and Contributions}
  \begin{block}{Main Question}
    Can we design a \textbf{compositional} static analysis for \textbf{Android Java}
    that detects deadlocks in large codebases, with:
    \begin{itemize}
      \item A clean \textbf{theoretical characterisation} of deadlocks
      \item A \textbf{decidable} and \textbf{tractable} core problem
      \item A practical implementation integrated in CI
    \end{itemize}
  \end{block}

  \begin{block}{High-Level Contributions}
    \begin{itemize}
      \item Abstract language with balanced re-entrant locks and nondeterministic control
      \item New deadlock condition based on \alert{critical pairs} of threads
      \item Proof that deadlock detection in this language is decidable and in NP
      \item Compositional implementation in Facebook's \texttt{INFER}, deployed at scale
    \end{itemize}
  \end{block}
\end{frame}

% =========================================================
\section{Critical Pairs and Deadlock Detection}
% =========================================================

\begin{frame}{Intuition: Critical Pairs}
  \begin{block}{Critical Pair (Informal)}
    A \textbf{critical pair} of a thread is a pair \((X,\ell)\) such that
    some execution of the thread acquires an \emph{unheld} lock \(\ell\)
    while already holding exactly the set of locks \(X\).
  \end{block}
  \begin{itemize}
    \item Captures \alert{which locks are held} when a new lock is acquired.
    \item Abstracts away the concrete control-flow and interleavings.
    \item Each thread has a \textbf{finite} set of critical pairs.
  \end{itemize}
\end{frame}

\begin{frame}{Two-Thread Deadlock Condition}
  \begin{block}{Deadlock Condition (2 Threads)}
    For two threads \(C_1\) and \(C_2\):
    \[
      C_1 \,||\, C_2 \text{ deadlocks}
      \iff \exists (X_1,\ell_1) \in \text{Crit}(C_1),
                 (X_2,\ell_2) \in \text{Crit}(C_2)
    \]
    such that
    \[
      \ell_1 \in X_2,\quad \ell_2 \in X_1,\quad X_1 \cap X_2 = \emptyset.
    \]
  \end{block}
  \begin{itemize}
    \item Each thread holds a lock the other is trying to acquire.
    \item The currently held lock sets do not overlap.
    \item Generalises to arbitrarily many threads (Theorem 4.4 in the paper).
  \end{itemize}
\end{frame}

\begin{frame}{Example: Classic Two-Thread Deadlock}
  \begin{exampleblock}{Two Threads}
    \begin{align*}
      C_1 &: \; acq(x); acq(y); skip; rel(y); rel(x) \\
      C_2 &: \; acq(y); acq(x); skip; rel(x); rel(y)
    \end{align*}
  \end{exampleblock}
  \vspace{-0.5em}
  \begin{itemize}
    \item Critical pairs:
      \begin{align*}
        \text{Crit}(C_1) &= \{ (\emptyset, x), (\{x\}, y) \} \\
        \text{Crit}(C_2) &= \{ (\emptyset, y), (\{y\}, x) \}
      \end{align*}
    \item Take \((X_1,\ell_1) = (\{x\}, y)\) and \((X_2,\ell_2) = (\{y\}, x)\):
      \begin{itemize}
        \item \(\ell_1 = y \in X_2 = \{y\}\)
        \item \(\ell_2 = x \in X_1 = \{x\}\)
        \item \(X_1 \cap X_2 = \emptyset\)
      \end{itemize}
    \item Condition holds \(\Rightarrow\) \alert{deadlock is possible}.
  \end{itemize}
\end{frame}

\begin{frame}{Guard Locks: Breaking the Deadlock}
  \begin{exampleblock}{Adding a Guard Lock}
    \begin{align*}
      C'_1 &= acq(z); C_1; rel(z) \\
      C'_2 &= acq(z); C_2; rel(z)
    \end{align*}
  \end{exampleblock}
  \vspace{-0.5em}
  \begin{itemize}
    \item Now:
      \begin{align*}
        \text{Crit}(C'_1) &= \{ (\emptyset, z), (\{z\}, x), (\{z,x\}, y) \} \\
        \text{Crit}(C'_2) &= \{ (\emptyset, z), (\{z\}, y), (\{z,y\}, x) \}
      \end{align*}
    \item Any potentially conflicting critical pairs share lock \(z\):
      \[
        \{z,x\} \cap \{z,y\} = \{z\} \neq \emptyset
      \]
    \item Deadlock condition fails \(\Rightarrow\) \alert{no deadlock}.
    \item Intuition: \(z\) acts as a \emph{guard lock} protecting the region.
  \end{itemize}
\end{frame}

% =========================================================
\section{Concurrent Programs}
% =========================================================

\begin{frame}{Abstract Language for Concurrency}
  \begin{itemize}
    \item Abstracts away data and heap; focuses only on locks and control.
    \item Statements \(C\) are built from:
      \begin{align*}
        C ::= &\ \texttt{skip} \mid p() \mid acq(\ell) \mid rel(\ell) \mid C;C \\
              &\mid \texttt{if(*) then C else C} \mid \texttt{while(*) do C}
      \end{align*}
    \item \textbf{Balanced statements} enforce lock discipline:
      \begin{itemize}
        \item Locks must be released in LIFO order
        \item Models scoped constructs like \texttt{synchronized} and \texttt{std::lock\_guard}
      \end{itemize}
    \item A parallel program is an \(n\)-tuple \(C_1 \,||\, \dots \,||\, C_n\).
  \end{itemize}
\end{frame}

\begin{frame}{Lock States and Configurations}
  \begin{itemize}
    \item Locks are \textbf{re-entrant}:
      \begin{itemize}
        \item A thread can acquire the same lock multiple times
        \item Lock state \(L : \text{Locks} \to \mathbb{N}\) counts acquisitions
      \end{itemize}
    \item We write \(\lfloor L \rfloor = \{ \ell \mid L(\ell) > 0 \}\) for held locks.
    \item A configuration is a pair \(\langle C, L \rangle\):
      \begin{itemize}
        \item \(C\): current statement
        \item \(L\): lock state
      \end{itemize}
    \item A concurrent configuration:
      \[
        \langle C_1 || \dots || C_n, (L_1,\dots,L_n) \rangle
      \]
      where each thread has its own lock state.
  \end{itemize}
\end{frame}

\begin{frame}{Deadlock Definition}
  \begin{itemize}
    \item Sequential step: \(\langle C, L \rangle \to \langle C', L' \rangle\).
    \item Parallel step (rule \textsc{(par i)}): advance one thread, provided
      it does not grab a lock already held by some other thread.
    \item Intuitively, we are deadlocked when:
      \begin{itemize}
        \item Each thread can individually make a step (sequentially)
        \item But no \emph{parallel} step is possible any more
      \end{itemize}
    \item Formal definition (simplified):
      \begin{itemize}
        \item A concurrent configuration is deadlocked if at least two threads
              are stuck in this way.
        \item A program deadlocks if some reachable configuration is deadlocked.
      \end{itemize}
  \end{itemize}
\end{frame}

% =========================================================
\section{Program Execution Traces}
% =========================================================

\begin{frame}{Executions as Traces}
  \begin{itemize}
    \item Each step either:
      \begin{itemize}
        \item Leaves the lock state unchanged
        \item Acquires a lock \(\ell\)
        \item Releases a lock \(\ell\)
      \end{itemize}
    \item We record only lock actions as a \textbf{trace} over alphabet \(\Sigma\):
      \[
        \Sigma = \{ \ell \mid \ell \in \text{Locks} \} \cup \{ \overline{\ell} \mid \ell \in \text{Locks} \}
      \]
    \item Example:
      \begin{itemize}
        \item Statement:
          \texttt{acq(x); if(*) then acq(y); rel(y) else acq(z); rel(z); rel(x)}
        \item Possible traces: \(x y \overline{y} \overline{x}\) and \(x z \overline{z} \overline{x}\)
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Dyck Words and Balanced Locking}
  \begin{itemize}
    \item For balanced statements, traces are \textbf{Dyck words}:
      \begin{itemize}
        \item Well-parenthesised strings of opens and closes
        \item Locks always released in reverse order of acquisition
      \end{itemize}
    \item Key property:
      \begin{itemize}
        \item For any balanced statement \(C\), all traces in \(L(C)\) are Dyck words.
        \item Executions never underflow the lock stack.
      \end{itemize}
    \item This structure is crucial for the decidability and the critical-pair
          characterisation of deadlocks.
  \end{itemize}
\end{frame}

\begin{frame}{Languages of Statements}
  \begin{itemize}
    \item Each statement \(C\) defines a language \(L(C) \subseteq \Sigma^\star\):
      \begin{itemize}
        \item All traces of possible executions of \(C\)
      \end{itemize}
    \item Defined inductively:
      \begin{align*}
        L(\texttt{skip}) &= \{\varepsilon\} &
        L(p()) &= L(\text{body}(p)) \\
        L(acq(\ell)) &= \{\ell\} &
        L(rel(\ell)) &= \{\overline{\ell}\} \\
        L(C_1;C_2) &= L(C_1) \cdot L(C_2) &
        L(\texttt{if(*) then } C_1 \texttt{ else } C_2) &= L(C_1) \cup L(C_2) \\
        L(\texttt{while(*) do } C) &= L(C)^\ast
      \end{align*}
    \item For balanced \(C\), \(L(C)\) is regular and consists of Dyck words.
  \end{itemize}
\end{frame}

% =========================================================
\section{Soundness and Completeness}
% =========================================================

\begin{frame}{Critical Pairs: Formal Definition}
  \begin{block}{Critical Pairs of a Statement}
    For a balanced statement \(C\):
    \[
      \text{Crit}(C) = \{ (\lfloor \langle u \rangle \rfloor, \ell)
      \mid \exists v.\; u \ell v \in L(C) \ \text{and}\ \ell \notin \lfloor \langle u \rangle \rfloor \}
    \]
    where \(\langle u \rangle\) is the cumulative lock effect of trace \(u\).
  \end{block}
  \begin{itemize}
    \item This is equivalent to: \emph{there exists an execution that acquires \(\ell\)
          while holding exactly \(X\)}.
    \item The paper shows the execution-based and language-based definitions coincide.
  \end{itemize}
\end{frame}

\begin{frame}{Deadlock Characterisation Theorem}
  \begin{block}{Theorem 4.4 (Simplified)}
    A parallel program \(C_1 || \dots || C_n\) deadlocks
    iff there exists an index set \(I \subseteq \{1,\dots,n\}\) with \(|I| \ge 2\)
    and critical pairs \((X_i,\ell_i) \in \text{Crit}(C_i)\) for each \(i \in I\) such that:
    \[
      X_i \cap \bigcup_{j \neq i} X_j = \emptyset
      \quad\text{and}\quad
      \ell_i \in \bigcup_{j \neq i} X_j \quad \text{for all } i \in I.
    \]
  \end{block}
  \begin{itemize}
    \item Each thread holds locks needed by the others.
    \item Held-lock sets are pairwise disjoint.
    \item This condition is both \textbf{sound} and \textbf{complete}.
  \end{itemize}
\end{frame}

\begin{frame}{Proof Idea (Very High Level)}
  \begin{itemize}
    \item Direction \((\Rightarrow)\) (deadlock \(\Rightarrow\) critical-pair conflict):
      \begin{itemize}
        \item Start from a deadlocked configuration.
        \item Project onto each thread and analyse the last lock acquisition step.
        \item Show that the corresponding lock states form the required \(X_i\).
      \end{itemize}
    \item Direction \((\Leftarrow)\) (critical-pair conflict \(\Rightarrow\) deadlock):
      \begin{itemize}
        \item Assume such critical pairs exist.
        \item Construct executions for each thread that reach the corresponding states.
        \item Use a scheduling argument to show a global deadlocked configuration exists.
      \end{itemize}
    \item Balanced locking and Dyck-word reasoning are crucial in both directions.
  \end{itemize}
\end{frame}

% =========================================================
\section{Complexity}
% =========================================================

\begin{frame}{Computing Critical Pairs Compositionally}
  \begin{itemize}
    \item The paper gives equations (C1)--(C6) describing \(\text{Crit}(C)\)
          \emph{by syntax} of \(C\).
    \item Examples:
      \begin{align*}
        \text{Crit}(\texttt{skip}) &= \emptyset \\
        \text{Crit}(p()) &= \text{Crit}(\text{body}(p)) \\[0.4em]
        \text{Crit}(C;C') &= \text{Crit}(C) \cup \text{Crit}(C') \\
        \text{Crit}(\texttt{if(*) then } C \texttt{ else } C') &=
          \text{Crit}(C) \cup \text{Crit}(C') \\[0.4em]
        \text{Crit}(acq(\ell);C;rel(\ell)) &=
          \{(\emptyset,\ell)\} \cup \{(X \cup \{\ell\},\ell') \mid (X,\ell') \in \text{Crit}(C),\ \ell' \neq \ell \}
      \end{align*}
    \item These identities allow a bottom-up computation of \(\text{Crit}(C)\).
  \end{itemize}
\end{frame}

\begin{frame}{Complexity Bounds}
  \begin{itemize}
    \item \textbf{Finite} and \textbf{computable}:
      \begin{itemize}
        \item For any balanced \(C\), \(\text{Crit}(C)\) is finite.
      \end{itemize}
    \item Complexity of deadlock detection (Theorem 5.5):
      \begin{itemize}
        \item The deadlock problem for this language is \textbf{decidable} and lies in \textbf{NP}.
        \item Idea: nondeterministically guess a set of threads and critical pairs,
              then check the deadlock condition in polynomial time.
      \end{itemize}
    \item For programs without procedure calls:
      \begin{itemize}
        \item Computing \(\text{Crit}(C)\) is polynomial in program size.
      \end{itemize}
    \item Lower bounds (e.g.\ NP-completeness) are left as future work.
  \end{itemize}
\end{frame}

% =========================================================
\section{Implementation}
% =========================================================

\begin{frame}{Core Abstract Interpretation}
  \begin{itemize}
    \item Implementation is an abstract interpretation that computes critical pairs.
    \item Abstract state:
      \[
        \alpha = \langle L, Z \rangle
      \]
      where
      \begin{itemize}
        \item \(L\): abstract lock state
        \item \(Z\): set of (approximate) critical pairs
      \end{itemize}
    \item Each command \(C\) defines a transformer $\llbracket C \rrbracket(\alpha)$.
    \item The join operation on states:
      \[
        \langle L, Z_1 \rangle \sqcup \langle L, Z_2 \rangle
        = \langle L, Z_1 \cup Z_2 \rangle
      \]
  \end{itemize}
\end{frame}

\begin{frame}{Compositionality of the Analysis}
  \begin{itemize}
    \item Procedure calls are handled via \textbf{summaries}:
      \begin{itemize}
        \item For each procedure \(p\) we precompute \(\text{Crit}(\text{body}(p))\).
        \item At a call \(p()\), we combine the current state with \(p\)'s summary.
      \end{itemize}
    \item Consequences:
      \begin{itemize}
        \item When code changes, only affected procedures and their callers need re-analysis.
        \item Most of the program can be reused from previous runs.
        \item This is essential for deployment in continuous integration.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Adapting to Android Java}
  \begin{itemize}
    \item The abstract language is mapped to real Java/Android code:
      \begin{itemize}
        \item \texttt{synchronized} methods/blocks \(\Rightarrow\) balanced lock regions
        \item Re-entrant monitors modelled as nested acquisitions
      \end{itemize}
    \item Android-specific refinements:
      \begin{itemize}
        \item Partial path-sensitivity for methods like \texttt{tryLock()} and UI-thread checks
        \item Lock naming via access-paths (\texttt{this.f.g}, etc.)
        \item Thread identity domain (\texttt{@UiThread}, \texttt{@WorkerThread}, background)
      \end{itemize}
    \item Implemented as the \texttt{starvation} analyser inside \texttt{INFER}.
  \end{itemize}
\end{frame}

% =========================================================
\section{Deployment and Results}
% =========================================================

\begin{frame}{Integration in Facebook's CI}
  \begin{itemize}
    \item \texttt{INFER} is part of Facebook's continuous integration:
      \begin{itemize}
        \item Every Android commit triggers static analyses, including deadlock analysis.
        \item The analyser appears as an automated reviewer on code reviews.
      \end{itemize}
    \item The deadlock analysis targets \textbf{code changes}, not whole apps:
      \begin{itemize}
        \item Summarise modified methods and their dependents
        \item Use heuristics to find relevant methods that share locks
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Quantitative Impact}
  \begin{itemize}
    \item Deployed on all Android commits for \(\sim\)2 years.
    \item Scale:
      \begin{itemize}
        \item Hundreds of thousands of commits analysed
        \item Typically \(2\text{k} - 5\text{k}\) methods per commit
      \end{itemize}
    \item Performance:
      \begin{itemize}
        \item Median total analysis time \(\approx 90\) seconds per commit
      \end{itemize}
    \item Effectiveness:
      \begin{itemize}
        \item 500+ deadlock reports issued
        \item \(\sim 54\%\) of these reports were fixed by developers
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Practical Considerations}
  \begin{itemize}
    \item The tool optimises for \textbf{actionability}, not pure soundness:
      \begin{itemize}
        \item Prefers fewer, high-quality warnings
        \item Accepts some false negatives to keep the noise low
      \end{itemize}
    \item Some non-fixed reports:
      \begin{itemize}
        \item May still be real bugs (fixed elsewhere or considered low priority)
        \item Some are false positives (e.g.\ infeasible concurrency patterns)
      \end{itemize}
    \item Overall: evidence that the analysis finds real, impactful bugs at scale.
  \end{itemize}
\end{frame}

% =========================================================
\section{Conclusion and Related Work}
% =========================================================

\begin{frame}{Related Work (Very Brief)}
  \begin{itemize}
    \item \textbf{Automata-theoretic} approaches:
      \begin{itemize}
        \item Communicating pushdown systems, nested locks, LTL model checking
      \end{itemize}
    \item \textbf{Static analyses} for deadlocks:
      \begin{itemize}
        \item Path-insensitive and path-sensitive tools for Java and C
        \item Often whole-program and non-compositional
      \end{itemize}
    \item \textbf{Dynamic and hybrid} techniques:
      \begin{itemize}
        \item Runtime monitoring, lock-order graphs, concolic execution
      \end{itemize}
    \item This paper:
      \begin{itemize}
        \item Places a compositional static analysis with strong theory into this landscape
        \item Focuses on large-scale industrial deployment
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Takeaways and Future Work}
  \begin{itemize}
    \item A new, \textbf{critical-pair based} characterisation of deadlocks for a balanced lock language.
    \item Deadlock detection in this setting is \textbf{decidable} and in \textbf{NP}.
    \item A compositional implementation scaled to tens of millions of LoC in production.
    \item \textbf{Formalisation}: full development mechanised in Coq (\(\sim 8.7\text{k}\) LOC).
  \end{itemize}
  \begin{block}{Future Directions}
    \begin{itemize}
      \item Extend the theory to richer languages (recursion, deterministic guards, nested parallelism)
      \item Sharpen complexity bounds (e.g.\ NP-completeness)
      \item Explore similar compositional ideas for other concurrency bugs
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[standout]
  \Huge Thank you! \\
  \vspace{1em}
  Questions?
\end{frame}

\end{document}
